#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <stdint.h>
#include <unistd.h>
#include <errno.h>
#include <time.h>
#include <assert.h>
#include <stdbool.h>

#include <sys/types.h>
#include <sys/time.h>

#ifdef WINDOWS
#include <winsock2.h>
#include <winsock.h>
#else
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>
#endif

#include "utils.h"
#include "netif.h"
#include "encryption.h"
#include "discover.h"
#include "session.h"
#include "accept.h"
#include "connect.h"

/* Magic number of discovery datagram: "TON1" */
#define TON_DISCOVER_MAGIC 0x544f4e31UL

/* Magic number of encrypted part of discovery datagram, once decrypted:
 * "ton1" */
#define TON_DISCOVER_MAGIC2 0x746f6e31UL

#define TON_ENC_PLAIN 0 /* not permitted by default */
#define TON_ENC_AES_256_CBC 1

#define DISCOVER_TIMESTAMP_TOLERANCE_SEC 300

#define DISCOVER_RD_OFFSET_MAGIC 0
#define DISCOVER_RD_OFFSET_ENC 4
#define DISCOVER_RD_OFFSET_PLEN 7
#define DISCOVER_RD_OFFSET_PAYLOAD 8
/* Format of the UDP announcement datagram sent using broadcast and/or
 * multicast by the host running "ton pull".
 *
 * Raw datagram data is as follows. All integers are in network byte order.
 * A valid TON announcement datagram is no more than 263 bytes.
 *
 * Position  Type      Description
 * 0-3       uint32    Magic number 0x54545431
 * 4-5       uint16    Type of encryption used to encrypt the payload.
 *                       0 = no encryption.
 *                       1 = AES-256-CBC.
 * 6         uint8     Reserved. Announcers must set this to 0.
 * 7         uint8     Payload length in bytes. Maximum is 255.
 * 8+        byte[payload_length]
 *                     Payload. If encryption type is 1, this consists of the
 *                     8-byte salt, then the 16-byte initialisation vector
 *                     (IV), then the encrypted data.
 */

#define DISCOVER_P_OFFSET_MAGIC 0
#define DISCOVER_P_OFFSET_CRC 4
#define DISCOVER_P_OFFSET_CRC_DATA_START 8
#define DISCOVER_P_OFFSET_RANDOM 8
#define DISCOVER_P_OFFSET_TIMESTAMP 24
#define DISCOVER_P_OFFSET_INV_PORT 28
#define DISCOVER_P_LENGTH 30
/* Unencrypted payload format is as follows. All integers are in network byte
 * order.
 *
 * Position  Type      Description
 * 0-3       uint32    Magic number 0x54545432
 * 4-7       uint32    CRC32 of payload bytes 8 to (plaintext payload length-1) inclusive.
 * 8-23      byte[16]  16 random bytes generated by sender.
 * 24-27     uint32    Lower 32 bits of Unix timestamp, to protect against
 *                       replay attacks.
 * 28-29     uint16    Invitation port number. The sender of this packet is
 *                     inviting the receiver to connect to the source address
 *                     of the packet on this TCP port number.
 * 30+                 Reserved for future expansion
 *
 * The encrypted payload may be up to 255 bytes long. If there are any bytes
 * after byte position 29 they should be ignored. This area may be used in
 * later versions.
 */

struct ton_discover_result {
    uint32_t magic;

    /* Announcer chooses a random salt and uses that for the encryption of each
     * announcement packet. The salt is included in plaintext in the packet.
     * The same salt is then used with the passphrase to create the encryption
     * key for the session. */
    unsigned char salt[8];

    PORT invitation_port;
};

static uint32_t
uint32_ntoh(const char *buf, int offset) {
    return ntohl(*(const uint32_t *)(buf + offset));
}

static uint16_t
uint16_ntoh(const char *buf, int offset) {
    return ntohs(*(const uint16_t *)(buf + offset));
}

static void
uint32_hton(char *buf, int offset, uint32_t value) {
    value = htonl(value);
    memcpy(buf + offset, &value, sizeof(value));
}

static void
uint16_hton(char *buf, int offset, uint16_t value) {
    value = htons(value);
    memcpy(buf + offset, &value, sizeof(value));
}

static uint32_t
crc32(const char *data, size_t length) {
    static uint32_t crc32_table[256] = {0};
    static int crc32_table_generated = 0;
    uint32_t checksum = 0xFFFFFFFFU;

    if (!crc32_table_generated) {
        for (uint32_t i = 0; i < 256; i++) {
            uint32_t ch = i;
            uint32_t crc = 0;
            for (int j = 0; j < 8; j++) {
                uint32_t b = (ch ^ crc) & 1;
                crc >>= 1;
                if (b)
                    crc ^= 0xEDB88320;
                ch >>= 1;
            }
            crc32_table[i] = crc;
        }
        crc32_table_generated = 1;
    }

    for (size_t i = 0; i < length; i++) {
        const uint32_t b = (checksum ^ data[i]) & 0xff;
        checksum = (checksum >> 8) ^ crc32_table[b];
    }
    return checksum ^ 0xFFFFFFFFU;
}

static int
validate_datagram(void *datagram, int datagram_length, const char *secret,
        size_t secret_length, int allow_unencrypted, int verbose,
        struct ton_discover_result *result) {
    unsigned long magic;
    unsigned long crc32_exp, crc32_obs;
    unsigned short enc;
    unsigned short enc_payload_length;
    unsigned short inv_port;
    unsigned long datagram_timestamp, ts_diff;
    int payload_length;
    time_t now;
    char *enc_payload_start;
    char payload[256];

    if (datagram_length < 8 || datagram_length > 263) {
        if (verbose)
            ton_error(0, 0, "validate_datagram: invalid length %d", datagram_length);
        return -1;
    }

    magic = uint32_ntoh(datagram, DISCOVER_RD_OFFSET_MAGIC);
    enc = uint16_ntoh(datagram, DISCOVER_RD_OFFSET_ENC);
    enc_payload_length = uint16_ntoh(datagram, DISCOVER_RD_OFFSET_PLEN - 1) & 0xff;
    enc_payload_start = ((char *) datagram) + DISCOVER_RD_OFFSET_PAYLOAD;

    if (magic != TON_DISCOVER_MAGIC) {
        if (verbose)
            ton_error(0, 0, "validate_datagram: first magic number incorrect (expected 0x%08lx, observed 0x%08lx)", TON_DISCOVER_MAGIC, magic);
        return -1;
    }

    if (enc != 0 && enc != 1) {
        if (verbose)
            ton_error(0, 0, "validate_datagram: invalid encryption type %hu", enc);
        return -1;
    }

    if (enc == 0) {
        if (!allow_unencrypted) {
            if (verbose)
                ton_error(0, 0, "validate_datagram: datagram is not encrypted, rejecting it.");
            return -1;
        }
        memcpy(payload, enc_payload_start, enc_payload_length);
        payload_length = enc_payload_length;
    }
    else {
        payload_length = ton_aes_256_cbc_decrypt(enc_payload_start,
                enc_payload_length, payload, sizeof(payload), secret,
                secret_length, result->salt);
        if (payload_length < 0) {
            if (verbose)
                ton_error(0, 0, "validate_datagram: announcement not encrypted with expected passphrase");
            return -1;
        }
    }

    if (verbose > 1) {
        ton_dump_hex(payload, payload_length, "decrypted payload");
    }

    magic = uint32_ntoh(payload, DISCOVER_P_OFFSET_MAGIC);
    crc32_exp = uint32_ntoh(payload, DISCOVER_P_OFFSET_CRC);

    if (magic != TON_DISCOVER_MAGIC2) {
        if (verbose)
            ton_error(0, 0, "validate_datagram: second magic number incorrect (expected 0x%08lx, observed 0x%08lx)", TON_DISCOVER_MAGIC2, magic);
        return -1;
    }

    crc32_obs = crc32(payload + DISCOVER_P_OFFSET_CRC_DATA_START, payload_length - DISCOVER_P_OFFSET_CRC_DATA_START);
    if (crc32_obs != crc32_exp) {
        if (verbose)
            ton_error(0, 0, "validate_datagram: CRC32 incorrect (expected 0x%08lx, calculated 0x%08lx)", crc32_exp, crc32_obs);
        return -1;
    }

    datagram_timestamp = uint32_ntoh(payload, DISCOVER_P_OFFSET_TIMESTAMP);
    now = time(NULL);
    ts_diff = (unsigned long) (now & 0xFFFFFFFF) - datagram_timestamp;
    if (abs((int32_t)ts_diff) > DISCOVER_TIMESTAMP_TOLERANCE_SEC) {
        if (verbose)
            ton_error(0, 0, "validate_datagram: timestamp out of date, difference %d seconds", abs((int32_t) ts_diff));
        return -1;
    }

    inv_port = uint16_ntoh(payload, DISCOVER_P_OFFSET_INV_PORT);

    result->magic = magic;
    result->invitation_port = inv_port;

    return 0;
}

static int
make_announce_datagram(char *dest, int dest_max, const char *secret,
        size_t secret_length, int enc_type, PORT invitation_port,
        const unsigned char *salt8) {
    char plain[256];
    int plain_payload_length;
    int encrypted_payload_length;

    uint32_hton(dest, DISCOVER_RD_OFFSET_MAGIC, TON_DISCOVER_MAGIC);
    uint16_hton(dest, DISCOVER_RD_OFFSET_ENC, enc_type);

    memset(plain, 0, sizeof(plain));
    uint32_hton(plain, DISCOVER_P_OFFSET_MAGIC, TON_DISCOVER_MAGIC2);
    ton_set_random_bytes(plain + DISCOVER_P_OFFSET_RANDOM, 16);
    uint32_hton(plain, DISCOVER_P_OFFSET_TIMESTAMP, (uint32_t) (time(NULL) & 0xFFFFFFFF));
    uint16_hton(plain, DISCOVER_P_OFFSET_INV_PORT, invitation_port);

    plain_payload_length = DISCOVER_P_LENGTH;

    uint32_hton(plain, DISCOVER_P_OFFSET_CRC, crc32(plain + DISCOVER_P_OFFSET_CRC_DATA_START, plain_payload_length - DISCOVER_P_OFFSET_CRC_DATA_START));

    if (enc_type == TON_ENC_PLAIN) {
        if (dest_max < DISCOVER_RD_OFFSET_PAYLOAD + plain_payload_length) {
            ton_error(0, 0, "make_announce_datagram: dest_max is too small (%d < %d)", dest_max, DISCOVER_RD_OFFSET_PAYLOAD + plain_payload_length);
            return -1;
        }
        memcpy(dest + DISCOVER_RD_OFFSET_PAYLOAD, plain, plain_payload_length);
        encrypted_payload_length = plain_payload_length;
    }
    else if (enc_type == TON_ENC_AES_256_CBC) {
        encrypted_payload_length = ton_aes_256_cbc_encrypt(plain,
                plain_payload_length, dest + DISCOVER_RD_OFFSET_PAYLOAD,
                dest_max - DISCOVER_RD_OFFSET_PAYLOAD, secret, secret_length,
                salt8);
        if (encrypted_payload_length < 0) {
            ton_error(0, 0, "make_announce_datagram: ton_aes_256_cbc_encrypt() failed");
            return -1;
        }
    }
    else {
        ton_error(0, 0, "make_announce_datagram: unrecognised enc_type %d", enc_type);
        return -1;
    }

    uint16_hton(dest, 6, encrypted_payload_length);
    return 8 + encrypted_payload_length;
}

static void
sockaddr_set_port(struct sockaddr *sa, PORT port) {
    if (sa->sa_family == AF_INET) {
        ((struct sockaddr_in *) sa)->sin_port = htons(port);
    }
    else if (sa->sa_family == AF_INET6) {
        ((struct sockaddr_in6 *) sa)->sin6_port = htons(port);
    }
}

int
make_multicast_receiver(struct ton_discover_options *opts, int address_family,
        const char *multicast_addr_str, PORT port) {
    struct addrinfo hints;
    struct addrinfo *addrinfo = NULL;
    char port_str[20];
    int listener = -1;
    int rc;
#ifdef WINDOWS
    const BOOL one = 1;
#else
    const int one = 1;
#endif

    memset(&hints, 0, sizeof(hints));

    hints.ai_family = address_family;
    hints.ai_socktype = SOCK_DGRAM;
    hints.ai_flags = AI_PASSIVE;

    snprintf(port_str, sizeof(port_str), "%hu", port);

    rc = getaddrinfo(NULL, port_str, &hints, &addrinfo);
    if (rc != 0) {
        ton_error(0, 0, "make_multicast_receiver: getaddrinfo: %s", gai_strerror(rc));
        goto fail;
    }

    /* Create a socket and bind it to the given port, so we receive any
     * datagrams sent to us on that port. */
    listener = socket(addrinfo->ai_family, addrinfo->ai_socktype, addrinfo->ai_protocol);
    if (listener < 0) {
        ton_socket_error(0, "make_multicast_receiver: socket");
        goto fail;
    }

    if (setsockopt(listener, SOL_SOCKET, SO_REUSEADDR, (const char *) &one, sizeof(one)) != 0) {
        ton_socket_error(0, "make_multicast_receiver: setsockopt SO_REUSEADDR");
        goto fail;
    }

    if (address_family == AF_INET6) {
        /* Make this an IPv6-only socket, so we can bind to the same port
         * with an IPv4 socket. */
        if (setsockopt(listener, IPPROTO_IPV6, IPV6_V6ONLY, (const char *) &one, sizeof(one)) != 0) {
            ton_socket_error(0, "make_multicast_receiver: setsockopt IPV6_V6ONLY");
        }
    }

    rc = bind(listener, addrinfo->ai_addr, addrinfo->ai_addrlen);
    if (rc != 0) {
        ton_socket_error(0, "make_multicast_receiver: bind");
        goto fail;
    }

    rc = multicast_interfaces_subscribe(listener, multicast_addr_str, opts->include_global_addresses);
    if (rc <= 0) {
        ton_socket_error(0, "failed to join multicast group %s on any interface", multicast_addr_str);
        goto fail;
    }

end:
    if (addrinfo)
        freeaddrinfo(addrinfo);

    return listener;

fail:
    if (listener >= 0) {
        closesocket(listener);
    }
    listener = -1;
    goto end;
}

/* Create receiving sockets in dlctx to listen for IPv4 and/or IPv6
 * announcement datagrams, as appropriate. Called by tondlctx_init().
 */
static int
tondlctx_receive_enable(struct tondlctx *dlctx, struct ton_discover_options *opts) {
    if (opts->address_families & TON_IPV4) {
        dlctx->receivers[0] = make_multicast_receiver(opts, AF_INET, dlctx->multicast_address_ipv4, opts->discover_port);
        if (dlctx->receivers[0] < 0) {
            goto fail;
        }
    }

    if (opts->address_families & TON_IPV6) {
        dlctx->receivers[1] = make_multicast_receiver(opts, AF_INET6, dlctx->multicast_address_ipv6, opts->discover_port);
        if (dlctx->receivers[1] < 0) {
            goto fail;
        }
    }

    if (opts->listening_cb && !dlctx->listening_cb_called) {
        /* Call the callback to say that we set everything up correctly and
         * we're now listening for announcements via UDP */
        opts->listening_cb(opts->listening_cb_cookie);
        dlctx->listening_cb_called = 1;
    }
    return 0;

fail:
    for (int i = 0; i < 2; i++) {
        if (dlctx->receivers[i] >= 0) {
            closesocket(dlctx->receivers[i]);
            dlctx->receivers[i] = -1;
        }
    }
    return -1;
}

/* Close our receiving sockets if they're open, and unsubscribe them from the
 * relevant multicast groups. Called by tondlctx_destroy(). */
static void
tondlctx_receive_disable(struct tondlctx *ctx) {
    for (int i = 0; i < 2; i++) {
        if (ctx->receivers[i] >= 0) {
            multicast_interfaces_unsubscribe(ctx->receivers[i], i == 0 ? ctx->multicast_address_ipv4 : ctx->multicast_address_ipv6);
            closesocket(ctx->receivers[i]);
            ctx->receivers[i] = -1;
        }
    }
}

int
tondlctx_init(struct tondlctx *ctx, struct ton_discover_options *opts) {
    memset(ctx, 0, sizeof(*ctx));

    ctx->receivers[0] = ctx->receivers[1] = -1;

    ctx->multicast_address_ipv4 = strdup(opts->multicast_address_ipv4);
    if (ctx->multicast_address_ipv4 == NULL)
        goto fail;

    ctx->multicast_address_ipv6 = strdup(opts->multicast_address_ipv6);
    if (ctx->multicast_address_ipv6 == NULL)
        goto fail;

    if (tondlctx_receive_enable(ctx, opts) < 0) {
        goto fail;
    }

    return 0;

fail:
    tondlctx_destroy(ctx);
    return -1;
}

int
tondlctx_set_multicast_addr(struct tondlctx *ctx, const char *addr, bool ipv6) {
    char *new_addr = strdup(addr);
    if (new_addr == NULL)
        return -1;
    if (ipv6) {
        free(ctx->multicast_address_ipv6);
        ctx->multicast_address_ipv6 = new_addr;
    }
    else {
        free(ctx->multicast_address_ipv4);
        ctx->multicast_address_ipv4 = new_addr;
    }
    return 0;
}

void
tondlctx_destroy(struct tondlctx *ctx) {
    tondlctx_receive_disable(ctx);
    free(ctx->multicast_address_ipv4);
    free(ctx->multicast_address_ipv6);
}


int
tondlctx_fdset_add_receivers(struct tondlctx *ctx, fd_set *set) {
    int maxfd = -1;
    for (int i = 0; i < 2; ++i) {
        if (ctx->receivers[i] >= 0) {
            FD_SET(ctx->receivers[i], set);
            if (ctx->receivers[i] > maxfd)
                maxfd = ctx->receivers[i];
        }
    }
    return maxfd;
}

int
tondlctx_fdset_contains_receivers(struct tondlctx *ctx, fd_set *set) {
    for (int i = 0; i < 2; ++i) {
        if (ctx->receivers[i] >= 0 && FD_ISSET(ctx->receivers[i], set))
            return 1;
    }
    return 0;
}

int
tondlctx_receive(struct tondlctx *dlctx, struct ton_discover_options *opts,
        struct sockaddr_storage *peer_addr_r, int *peer_addr_length_r,
        PORT *invitation_port_r, unsigned char *salt, size_t *salt_len) {
    int rc;
    int discovered = 0;

    do {
        int maxfd = -1;
        fd_set readfds;

        /* Wait for messages on both the IPv4 and IPv6 socket */
        FD_ZERO(&readfds);
        for (int i = 0; i < 2; i++) {
            if (dlctx->receivers[i] >= 0) {
                FD_SET(dlctx->receivers[i], &readfds);
                if (dlctx->receivers[i] > maxfd)
                    maxfd = dlctx->receivers[i];
            }
        }
        rc = select(maxfd + 1, &readfds, NULL, NULL, NULL);
        if (rc < 0) {
            ton_socket_error(0, "discover_listen: select");
            break;
        }

        /* Something happened, check on each socket */
        for (int i = 0; !discovered && i < 2; i++) {
            char datagram[512];
            struct sockaddr_storage peer_addr;
            socklen_t addr_len = sizeof(peer_addr);
            int listener = dlctx->receivers[i];

            if (listener < 0 || !FD_ISSET(listener, &readfds)) {
                continue;
            }

            rc = recvfrom(listener, datagram, sizeof(datagram), 0, (struct sockaddr *) &peer_addr, &addr_len);
            if (rc < 0) {
                ton_socket_error(0, "discover_listen: recvfrom");
            }
            else {
                struct ton_discover_result result;
                //ton_dump_hex(datagram, rc, "received datagram");
                if (validate_datagram(datagram, rc, opts->passphrase,
                            opts->passphrase_length, 0, opts->verbose,
                            &result) == 0) {
                    *invitation_port_r = result.invitation_port;
                    memcpy(peer_addr_r, &peer_addr, addr_len);
                    *peer_addr_length_r = addr_len;
                    *salt_len = 8;
                    memcpy(salt, result.salt, *salt_len);
                    discovered = 1;
                }
                if (opts->received_announcement_cb != NULL) {
                    /* Inform our caller that we got a valid or invalid
                     * announcement... */
                    opts->received_announcement_cb(
                            opts->received_announcement_cb_cookie,
                            (const struct sockaddr *) &peer_addr,
                            addr_len, discovered,
                            discovered ? result.invitation_port : 0);
                }
            }
        }
    } while (!discovered);

    if (discovered)
        rc = 0;
    else
        rc = -1;

    return rc;
}

static int
make_dgram_addr_info(const char *multicast_addr, PORT announce_port, struct addrinfo **res) {
    struct addrinfo hints;
    char port_str[20];
    int rc;
    memset(&hints, 0, sizeof(hints));
    hints.ai_family = AF_UNSPEC;
    hints.ai_socktype = SOCK_DGRAM;
    hints.ai_flags = AI_PASSIVE;
    snprintf(port_str, sizeof(port_str), "%hu", announce_port);
    rc = getaddrinfo(multicast_addr, port_str, &hints, res);
    if (rc != 0) {
        ton_error(0, 0, "discover_announce: getaddrinfo multicast: %s", gai_strerror(rc));
        return -1;
    }
    return 0;
}

static int get_udp_protocol_number(void) {
#ifdef WINDOWS
    struct protoent *udp = getprotobyname("udp");
    return udp->p_proto;
#else
    struct protoent *result;
    struct protoent result_buf;
    char *buf = NULL;
    size_t buflen = 1024;
    int rc;

    buf = malloc(buflen);

    errno = 0;
    while ((rc = getprotobyname_r("udp", &result_buf, buf, buflen, &result)) != 0 && errno == ERANGE) {
        char *new_buf = realloc(buf, buflen * 2);
        if (new_buf) {
            buflen *= 2;
            buf = new_buf;
        }
        else {
            free(buf);
            return -1;
        }
    }

    if (rc != 0) {
        free(buf);
        return -1;
    }

    rc = result->p_proto;
    free(buf);

    return rc;
#endif
}

int
tondactx_init(struct tondactx *dactx, struct ton_discover_options *opts) {
    int rc;
    int num_valid_sockets = 0;
#ifdef WINDOWS
    const BOOL one = 1;
#else
    const int one = 1;
#endif
    int udp_proto_number = get_udp_protocol_number();

    if (udp_proto_number < 0) {
        ton_socket_error(0, "couldn't look up protocol number for UDP");
        return -1;
    }

    memset(dactx, 0, sizeof(*dactx));

    dactx->multicast_address_ipv4 = strdup(opts->multicast_address_ipv4);
    dactx->multicast_address_ipv6 = strdup(opts->multicast_address_ipv6);
    dactx->announce_port = opts->discover_port;
    dactx->announcement_round_seq = 0;

    /* Think up a random salt to use with the encryption of announcement
     * packets, and encryption of the resulting session */
    ton_set_random_bytes((char *) dactx->session_salt, sizeof(dactx->session_salt));

    /* To maximise the chance of our announcement reaching our peer, we want
     * to try a broadcast packet on every interface on which we can broadcast,
     * and a multicast packet on every interface that supports multicast and
     * has a non-public IP address. The flags in announcement_types can inhibit
     * either of these. */

    if (opts->announcement_types & TON_ANNOUNCE_BROADCAST) {
        errno = 0;
        dactx->broadcast_ifs = ton_get_broadcast_ifs(opts->address_families, opts->include_global_addresses);
        if (dactx->broadcast_ifs == NULL && errno != 0) {
            ton_error(0, errno, "failed to get list of broadcast-enabled interfaces");
        }
    }

    if (opts->announcement_types & TON_ANNOUNCE_MULTICAST) {
        errno = 0;
        dactx->multicast_ifs = ton_get_multicast_ifs(opts->address_families, opts->include_global_addresses);
        if (dactx->multicast_ifs == NULL && errno != 0) {
            ton_error(0, errno, "failed to get list of multicast-enabled interfaces");
        }
    }

    /* If we have no suitable interfaces, bail out early rather than failing
     * to announce loads of times... */
    if (dactx->multicast_ifs == NULL && dactx->broadcast_ifs == NULL) {
        ton_error(0, 0, "no suitable network interfaces found for announcement");
        goto fail;
    }

    /* Initialise sockets to send broadcast packets on... */
    for (struct ton_netif *iface = dactx->broadcast_ifs; iface; iface = iface->next) {
        if (iface->bc_valid) {
            iface->sock = socket(iface->family, SOCK_DGRAM, udp_proto_number);
            if (iface->sock < 0) {
                ton_socket_error(0, "socket");
                goto fail;
            }
            rc = setsockopt(iface->sock, SOL_SOCKET, SO_BROADCAST, (const char *) &one, sizeof(one));
            if (rc < 0) {
                ton_socket_error(0, "discover_announce: setsockopt SO_BROADCAST");
                goto fail;
            }
            sockaddr_set_port((struct sockaddr *) &iface->bc_addr, dactx->announce_port);
        }
        if (iface->sock >= 0) {
            /* Datagrams from this socket must come from this interface's
             * address, so that if we have multiple addresses we sent an
             * announcement from each address. */
            if (bind(iface->sock, (struct sockaddr *) &iface->if_addr, iface->if_addr_len) < 0) {
                ton_socket_error(0, "failed to bind socket");
                closesocket(iface->sock);
                iface->sock = -1;
            }
            num_valid_sockets++;
        }
    }

    /* ... and initialise sockets to send multicast packets on. */
    for (struct ton_netif *iface = dactx->multicast_ifs; iface; iface = iface->next) {
        iface->sock = socket(iface->family, SOCK_DGRAM, udp_proto_number);
        if (iface->sock < 0) {
            ton_socket_error(0, "socket");
            goto fail;
        }

        if (iface->family == AF_INET) {
            struct sockaddr_in *sin = (struct sockaddr_in *)&iface->if_addr;
            rc = setsockopt(iface->sock, IPPROTO_IP, IP_MULTICAST_IF, (const char *) &sin->sin_addr, sizeof(sin->sin_addr));
            if (rc != 0) {
                /* Failed to enable this socket for multicast traffic,
                 * perhaps because it's a localhost or link-local address.
                 * This isn't a fatal error unless there are no more
                 * sockets. */
                closesocket(iface->sock);
                iface->sock = -1;
            }
        }
        else if (iface->family == AF_INET6) {
            rc = setsockopt(iface->sock, IPPROTO_IPV6, IPV6_MULTICAST_IF, (const char *) &iface->if_index_ipv6, sizeof(iface->if_index_ipv6));
            if (rc != 0) {
                //ton_socket_error(0, "failed to enable IPv6 socket for multicast traffic");
                closesocket(iface->sock);
                iface->sock = -1;
            }
        }
        if (iface->sock >= 0) {
            if (opts->multicast_ttl > 0) {
                rc = setsockopt(iface->sock,
                        iface->family == AF_INET6 ? IPPROTO_IPV6 : IPPROTO_IP,
                        iface->family == AF_INET6 ? IPV6_MULTICAST_HOPS : IP_MULTICAST_TTL,
                        (const char *) &opts->multicast_ttl,
                        sizeof(opts->multicast_ttl));
                if (rc != 0) {
                    ton_socket_error(0, "tondactx_init: setsockopt IP_MULTICAST_TTL");
                }
            }

            /* Datagrams from this socket must come from this interface's
             * address, so that if we have multiple addresses we sent an
             * announcement from each address. */
            if (bind(iface->sock, (struct sockaddr *) &iface->if_addr, iface->if_addr_len) < 0) {
                ton_socket_error(0, "tondactx_init: failed to bind socket");
                closesocket(iface->sock);
                iface->sock = -1;
            }
            num_valid_sockets++;
        }
    }

    if (num_valid_sockets == 0) {
        ton_socket_error(0, "no suitable network interfaces found for announcement. Last socket error was");
    }

    /* Get an addrinfo for our multicast group addresses, which we will be
     * announcing to as well as to any broadcast addresses we find. */
    if (make_dgram_addr_info(dactx->multicast_address_ipv4, dactx->announce_port, &dactx->multicast_addrinfo_ipv4) != 0)
        goto fail;
    if (make_dgram_addr_info(dactx->multicast_address_ipv6, dactx->announce_port, &dactx->multicast_addrinfo_ipv6) != 0)
        goto fail;

    return 0;

fail:
    tondactx_destroy(dactx);
    return -1;
}

int
tondactx_set_multicast_addr(struct tondactx *ctx, const char *addr, bool ipv6) {
    char *new_addr = strdup(addr);
    if (new_addr == NULL)
        return -1;
    if (ipv6) {
        free(ctx->multicast_address_ipv6);
        ctx->multicast_address_ipv6 = new_addr;
    }
    else {
        free(ctx->multicast_address_ipv4);
        ctx->multicast_address_ipv4 = new_addr;
    }
    return 0;
}

void
tondactx_set_invitation_port(struct tondactx *ctx, int sa_family, PORT port) {
    if (sa_family == AF_INET)
        ctx->invitation_port4 = port;
    else if (sa_family == AF_INET6)
        ctx->invitation_port6 = port;
}

void
tondactx_destroy(struct tondactx *ctx) {
    free(ctx->multicast_address_ipv4);
    free(ctx->multicast_address_ipv6);
    if (ctx->multicast_addrinfo_ipv4 != NULL) {
        freeaddrinfo(ctx->multicast_addrinfo_ipv4);
    }
    if (ctx->multicast_addrinfo_ipv6 != NULL) {
        freeaddrinfo(ctx->multicast_addrinfo_ipv6);
    }
    ton_netif_list_free(ctx->broadcast_ifs, 1);
    ton_netif_list_free(ctx->multicast_ifs, 1);
}

int
tondactx_announce(struct tondactx *dactx, struct ton_discover_options *opts) {
    int num_sockets_succeeded = 0;
    int addr_families[2] = { AF_INET6, AF_INET };
    PORT invitation_ports[2] = { dactx->invitation_port6, dactx->invitation_port4 };
    bool callback_aborted = false; /* set to true if receive_announcement_cb() aborts us */

    for (int af = 0; !callback_aborted && af < 2; ++af) {
        int addr_family = addr_families[af];
        PORT invitation_port = invitation_ports[af];
        char datagram[262];
        int datagram_length;

        if (invitation_port == 0)
            continue;

        datagram_length = make_announce_datagram(datagram, sizeof(datagram),
                opts->passphrase, opts->passphrase_length,
                TON_ENC_AES_256_CBC, invitation_port, dactx->session_salt);
        if (datagram_length < 0) {
            ton_error(0, errno, "discover_announce: failed to build datagram");
            return -1;
        }

        /* Go through the list of broadcast-enabled interfaces, and the list of
         * multicast-enabled interfaces, and send an announcement datagram on
         * the socket we've opened for each of them. */
        for (int type = 0; type < 2; ++type) {
            struct ton_netif *list = (type == 0 ? dactx->broadcast_ifs : dactx->multicast_ifs);

            if (list == dactx->broadcast_ifs && (opts->announcement_types & TON_ANNOUNCE_BROADCAST) == 0)
                continue;
            if (list == dactx->multicast_ifs && (opts->announcement_types & TON_ANNOUNCE_MULTICAST) == 0)
                continue;

            for (struct ton_netif *iface = list; !callback_aborted && iface; iface = iface->next) {
                ssize_t bytes_sent;
                struct sockaddr *sa;
                int sa_len;
                char addr_str[100];

                /* Skip sockets which failed setup in some way */
                if (iface->sock < 0) {
                    continue;
                }

                /* Make sure this socket corresponds with the address family
                 * we're using on this iteration of the outer loop */
                if (addr_family != iface->family) {
                    continue;
                }

                if (type == 0) {
                    /* Send to broadcast address */
                    sa = (struct sockaddr *) &iface->bc_addr;
                    sa_len = iface->bc_addr_len;
                }
                else {
                    /* Send to our IPv4 or IPv6 multicast group address */
                    if (iface->family == AF_INET) {
                        sa = dactx->multicast_addrinfo_ipv4->ai_addr;
                        sa_len = dactx->multicast_addrinfo_ipv4->ai_addrlen;
                    }
                    else if (iface->family == AF_INET6) {
                        sa = dactx->multicast_addrinfo_ipv6->ai_addr;
                        sa_len = dactx->multicast_addrinfo_ipv6->ai_addrlen;
                    }
                    else {
                        assert(0);
                    }
                }

                if (opts->verbose) {
                    int rc;
                    if ((rc = getnameinfo((struct sockaddr *) &iface->if_addr,
                                iface->if_addr_len, addr_str, sizeof(addr_str),
                                NULL, 0, NI_NUMERICHOST | NI_NUMERICSERV)) < 0) {
                        ton_error(0, 0, "getnameinfo: %s", gai_strerror(rc));
                    }
                    else {
                        ton_error(0, 0, "announced from %s", addr_str);
                    }
                }

                bytes_sent = sendto(iface->sock, datagram, datagram_length, 0, sa, sa_len);
                if (bytes_sent < 0) {
                    ton_socket_error(0, "discover_announce: sendto");
                }
                else if (bytes_sent < datagram_length) {
                    ton_error(0, 0, "discover_announce: expected to send %d bytes but only sent %d", datagram_length, (int) bytes_sent);
                }
                else {
                    if (opts->sent_announcement_cb != NULL) {
                        int rc = opts->sent_announcement_cb(
                                opts->sent_announcement_cb_cookie,
                                dactx->announcement_round_seq,
                                num_sockets_succeeded,
                                (struct sockaddr *) &iface->if_addr,
                                iface->if_addr_len, sa, sa_len
                        );
                        if (rc != 0) {
                            ton_error(0, 0, "announcements aborted");
                            callback_aborted = true;
                        }
                    }
                    num_sockets_succeeded++;
                }
            }
        }
    }

    dactx->announcement_round_seq++;

    if (callback_aborted)
        return -1;

    /* Return -1 (failure) if every attempt to send failed. */
    if (num_sockets_succeeded == 0) {
        ton_error(0, 0, "failed to send announcement on any socket");
    }
    return num_sockets_succeeded == 0 ? -1 : 0;
}


int
ton_discover_options_init(struct ton_discover_options *opts, const char *passphrase, int passphrase_length) {
    memset(opts, 0, sizeof(*opts));
    opts->multicast_address_ipv4 = strdup(TON_MULTICAST_GROUP_IPV4);
    opts->multicast_address_ipv6 = strdup(TON_MULTICAST_GROUP_IPV6);
    opts->passphrase = malloc(passphrase_length + 1);
    memcpy(opts->passphrase, passphrase, passphrase_length);
    opts->passphrase[passphrase_length] = '\0';
    opts->passphrase_length = passphrase_length;
    opts->discover_port = TON_DEFAULT_DISCOVER_PORT;
    opts->listen_port = TON_DEFAULT_LISTEN_PORT;
    opts->max_announcements = 0;
    opts->announcement_interval_ms = 1000;
    opts->multicast_ttl = 0;
    opts->address_families = TON_IP_BOTH;
    opts->announcement_types = TON_ANNOUNCE_BOTH;
    return 0;
}

/* ton_discover_options option setters */
int
ton_discover_set_multicast_ipv4_address(struct ton_discover_options *opts, const char *addr) {
    if (addr == NULL)
        addr = TON_MULTICAST_GROUP_IPV4;
    if (opts->multicast_address_ipv4)
        free(opts->multicast_address_ipv4);
    opts->multicast_address_ipv4 = strdup(addr);
    return 0;
}

int
ton_discover_set_multicast_ipv6_address(struct ton_discover_options *opts, const char *addr) {
    if (addr == NULL)
        addr = TON_MULTICAST_GROUP_IPV6;
    if (opts->multicast_address_ipv6)
        free(opts->multicast_address_ipv6);
    opts->multicast_address_ipv6 = strdup(addr);
    return 0;
}

void
ton_discover_set_address_families(struct ton_discover_options *opts, int f) {
    switch (f) {
        case TON_IPV4_ONLY:
        case TON_IPV6_ONLY:
        case TON_IP_BOTH:
            opts->address_families = f;
            break;
    }
}

void
ton_discover_set_announcement_types(struct ton_discover_options *opts, int a) {
    switch (a) {
        case TON_ANNOUNCE_BROADCAST_ONLY:
        case TON_ANNOUNCE_MULTICAST_ONLY:
        case TON_ANNOUNCE_BOTH:
            opts->announcement_types = a;
            break;
    }
}

void
ton_discover_set_listen_port(struct ton_discover_options *opts, int port) {
    if (port >= 0)
        opts->listen_port = port;
    else
        opts->listen_port = TON_DEFAULT_LISTEN_PORT;
}

void
ton_discover_set_discover_port(struct ton_discover_options *opts, int port) {
    if (port > 0)
        opts->discover_port = port;
    else
        opts->discover_port = TON_DEFAULT_DISCOVER_PORT;
}

void
ton_discover_set_verbose(struct ton_discover_options *opts, int verbose) {
    opts->verbose = verbose;
}

void
ton_discover_set_listening_callback(struct ton_discover_options *opts,
        tondl_listening_cb listening_cb, void *cookie) {
    opts->listening_cb = listening_cb;
    opts->listening_cb_cookie = cookie;
}

void
ton_discover_set_received_announcement_callback(struct ton_discover_options *opts,
        tondl_received_announcement_cb received_announcement_cb, void *cookie) {
    opts->received_announcement_cb = received_announcement_cb;
    opts->received_announcement_cb_cookie = cookie;
}

void
ton_discover_set_sent_announcement_callback(struct ton_discover_options *opts,
        tonda_sent_announcement_cb sent_announcement_cb, void *cookie) {
    opts->sent_announcement_cb = sent_announcement_cb;
    opts->sent_announcement_cb_cookie = cookie;
}

void
ton_discover_set_announcements(struct ton_discover_options *opts,
        int max_announcements, int announcement_interval_ms) {
    opts->max_announcements = max_announcements;

    /* Don't make announcement rounds more than once every 0.1 seconds. */
    if (announcement_interval_ms < 100)
        announcement_interval_ms = 100;

    opts->announcement_interval_ms = announcement_interval_ms;
}

void
ton_discover_set_multicast_ttl(struct ton_discover_options *opts, int ttl) {
    opts->multicast_ttl = ttl;
}

void
ton_discover_set_include_global_addresses(struct ton_discover_options *opts, bool include_global) {
    opts->include_global_addresses = include_global;
}

void
ton_discover_set_connect_timeout(struct ton_discover_options *opts, int timeout_ms) {
    opts->discover_connect_timeout_ms = timeout_ms;
}

void
ton_discover_options_destroy(struct ton_discover_options *opts) {
    if (opts) {
        free(opts->multicast_address_ipv4);
        free(opts->multicast_address_ipv6);
        free(opts->passphrase);
    }
}

int
ton_discover_and_connect(struct ton_discover_options *opts, struct ton_session *new_sess) {
    struct tondlctx dlctx;
    struct tonmcctx mcctx;
    bool ctx_valid = false;
    struct sockaddr_storage peer_addr;
    int peer_addr_len = sizeof(peer_addr);
    PORT peer_invitation_port;
    int handshake_completed = 0;
    struct timeval start_time, end_time;
    bool timeout_set = false;
    int rc;

    /* Initialise a discovery listen context */
    memset(&dlctx, 0, sizeof(dlctx));
    if (tondlctx_init(&dlctx, opts) != 0) {
        ton_error(0, errno, "failed to initialise listen context");
        return -1;
    }
    ctx_valid = true;

    gettimeofday(&start_time, NULL);
    if (opts->discover_connect_timeout_ms > 0) {
        struct timeval timeout;
        timeout.tv_sec = opts->discover_connect_timeout_ms / 1000;
        timeout.tv_usec = (opts->discover_connect_timeout_ms % 1000) * 1000;
        timeval_add(&start_time, &timeout, &end_time);
        timeout_set = true;
    }

    /* Initialise a multi-connect context, which is a glorified list of
     * partially-set-up non-blocking outgoing connection attempts. */
    tonmcctx_init(&mcctx);
    tonmcctx_set_verbose(&mcctx, opts->verbose);

    /* If we're using any multicast addresses other than the defaults, set
     * them now. */
    if (opts->multicast_address_ipv4) {
        tondlctx_set_multicast_addr(&dlctx, opts->multicast_address_ipv4, false);
    }
    if (opts->multicast_address_ipv6) {
        tondlctx_set_multicast_addr(&dlctx, opts->multicast_address_ipv6, true);
    }

    do {
        int max_receiver_fd, max_connector_fd, maxfd;
        struct timeval timeout, *timeoutp;
        fd_set readfds, writefds, exceptfds;

        FD_ZERO(&readfds);
        FD_ZERO(&writefds);
        FD_ZERO(&exceptfds);

        max_receiver_fd = tondlctx_fdset_add_receivers(&dlctx, &readfds);
        max_connector_fd = tonmcctx_fdset_add_sockets(&mcctx, &writefds);
        tonmcctx_fdset_add_sockets(&mcctx, &exceptfds);

        if (max_receiver_fd > max_connector_fd)
            maxfd = max_receiver_fd;
        else
            maxfd = max_connector_fd;

        if (timeout_set) {
            struct timeval now;
            gettimeofday(&now, NULL);
            timeval_diff(&end_time, &now, &timeout);
            timeoutp = &timeout;
        }
        else {
            timeoutp = NULL;
        }

        /* Wait for any new announcements (readfds) or any outgoing connection
         * attempts which have finished (writefds/exceptfds). */
        if ((rc = select(maxfd + 1, &readfds, &writefds, &exceptfds, timeoutp)) < 0) {
            ton_error(0, 0, "select");
        }

        if (rc == 0) {
            /* Timed out waiting for a valid announcement or waiting to make
             * a successful connection. */
            ton_error(0, 0, "timed out");
            goto fail;
        }

        if (tondlctx_fdset_contains_receivers(&dlctx, &readfds)) {
            unsigned char salt[8];
            size_t salt_len = sizeof(salt);
            unsigned char key[TON_KEY_SIZE];

            /* Listen until we receive a valid UDP datagram which was encrypted
             * with our secret. This datagram, when decrypted, tells us which
             * port to make a TCP connection to. */
            rc = tondlctx_receive(&dlctx, opts, &peer_addr, &peer_addr_len,
                    &peer_invitation_port, salt, &salt_len);
            if (rc != 0) {
                ton_error(0, 0, "tondctx_receive failed.");
                goto fail;
            }

            /* Connect to the host that sent us the valid announcement on
             * the port it specified, by adding to our tonmcctx context. This
             * will deal with multiple outgoing non-blocking connections. */
            ton_sockaddr_set_port((struct sockaddr *) &peer_addr, peer_invitation_port);

            ton_passphrase_to_key(opts->passphrase, opts->passphrase_length,
                    salt, salt_len, key, sizeof(key));

            tonmcctx_add_connect(&mcctx, (struct sockaddr *) &peer_addr, peer_addr_len, key);
        }

        if (tonmcctx_fdset_contains_sockets(&mcctx, &writefds) ||
                tonmcctx_fdset_contains_sockets(&mcctx, &exceptfds)) {
            struct ton_session *s = tonmcctx_run(&mcctx, &writefds, &exceptfds);
            if (s != NULL) {
                /* One of our outgoing connections successfully connected.
                 * Now block waiting for the handshake to succeed or fail. */
                if (ton_session_handshake(s) != 0) {
                    /* Handshake failed. Carry on waiting for announcements
                     * and completion of outgoing connections. */
                    ton_error(0, 0, "handshake failed");
                    ton_session_destroy(s);
                }
                else {
                    /* Handshake succeeded. This is our new session, and we'll
                     * close all the others. */
                    handshake_completed = 1;
                    *new_sess = *s;
                }

                /* Either way, free the buffer containing the session. The
                 * session has either been destroyed or copied to the caller. */
                free(s);
            }
        }

        /* If we couldn't connect or couldn't handshake with the host who
         * announced to us, go round and listen for announcements again. */
    } while (!handshake_completed);

    tondlctx_destroy(&dlctx);
    tonmcctx_destroy(&mcctx);
    ctx_valid = false;

    /* If we get here, we have discovered our peer and successfully established
     * a TCP connection, encrypted and authenticated using the passphrase. */
    return 0;

fail:
    if (ctx_valid) {
        tondlctx_destroy(&dlctx);
        tonmcctx_destroy(&mcctx);
    }
    return -1;
}

int
ton_discover_and_accept(struct ton_discover_options *opts, struct ton_session *new_sess) {
    struct tondactx dactx;
    bool dactx_valid = false;
    struct tonacctx acctx;
    bool acctx_valid = false;
    int announcement;
    char peer_addr_str[100];
    char peer_addr_port[30];
    const bool use_tls = true;
    PORT invitation_port4 = 0, invitation_port6 = 0;
    bool new_sess_valid = false;
    int rc;
    int num_failed_announcements = 0, max_failed_announcements = 10;

    /* Initialise a "discovery announce" context, where we will send
     * UDP datagrams, encrypted with the passphrase, which contain among
     * other things the port number we're inviting the other owner of
     * this passphrase to connect to. */
    memset(&dactx, 0, sizeof(dactx));
    memset(&acctx, 0, sizeof(acctx));
    if (tondactx_init(&dactx, opts) != 0) {
        goto fail;
    }
    dactx_valid = true;

    /* Open our listening TCP socket on the invitation port. */
    if (tonacctx_init(&acctx, NULL, NULL, opts->address_families,
                opts->listen_port, use_tls, opts->passphrase,
                opts->passphrase_length, dactx.session_salt,
                sizeof(dactx.session_salt)) < 0) {
        goto fail;
    }
    acctx_valid = true;

    invitation_port4 = tonacctx_get_listen_port(&acctx, AF_INET);
    invitation_port6 = tonacctx_get_listen_port(&acctx, AF_INET6);

    tondactx_set_invitation_port(&dactx, AF_INET, invitation_port4);
    tondactx_set_invitation_port(&dactx, AF_INET6, invitation_port6);

    /* Set the multicast addresses if required, but usually these are expected
     * to stay as their defaults. */
    if (opts->multicast_address_ipv4) {
        tondactx_set_multicast_addr(&dactx, opts->multicast_address_ipv4, false);
    }
    if (opts->multicast_address_ipv6) {
        tondactx_set_multicast_addr(&dactx, opts->multicast_address_ipv6, true);
    }

    if (opts->verbose) {
        if (invitation_port4)
            ton_error(0, 0, "IPv4: waiting for incoming connection on port %d...\n", invitation_port4);
        if (invitation_port6)
            ton_error(0, 0, "IPv6: waiting for incoming connection on port %d...\n", invitation_port6);
    }

    /* Send a number of announcements, with a suitable time gap in between.
     * Each announcement is a UDP datagram sent to a broadcast and/or
     * multicast address, so anything on the same network which is looking
     * for it should see it.
     * We keep sending announcements until we reach the limit
     * (num_announcements) or until we receive a connection on our TCP
     * listening socket which successfully completes a handshake proving
     * it has the right passphrase.
     */
    for (announcement = 0; opts->max_announcements == 0 || announcement < opts->max_announcements; announcement++) {
        if (announcement > 0) {
            /* Listen for incoming connections on our TCP socket. If
             * announcement_gap_ms milliseconds go by with nobody connecting to
             * us and completing a handshake, time out and make another UDP
             * announcement. */
            rc = tonacctx_accept(&acctx, opts->announcement_interval_ms, new_sess);
            if (rc < 0) {
                goto fail;
            }
            else if (rc == 0) {
                /* timeout */
            }
            else {
                /* Success! new_sess now contains a session which connected to
                 * the correct port and successfully handshook with us. */
                new_sess_valid = true;
                if (opts->verbose) {
                    if (ton_session_get_peer_addr(new_sess, peer_addr_str, sizeof(peer_addr_str), peer_addr_port, sizeof(peer_addr_port)) == 0) {
                        fprintf(stderr, "Accepted connection from %s:%s\n", peer_addr_str, peer_addr_port);
                    }
                }
                break;
            }
        }

        /* No successful incoming connection yet, so send out another
         * broadcast/multicast announcement inviting anyone who decrypts
         * it to connect to us. */
        rc = tondactx_announce(&dactx, opts);
        if (rc != 0) {
            num_failed_announcements++;
            if (num_failed_announcements > max_failed_announcements) {
                 break;
            }
        }
    }

end:
    if (dactx_valid)
        tondactx_destroy(&dactx);
    if (acctx_valid)
        tonacctx_destroy(&acctx);

    if (new_sess_valid)
        return 0;
    else
        return -1;

fail:
    if (new_sess_valid) {
        ton_session_destroy(new_sess);
        new_sess_valid = 0;
    }
    goto end;
}
