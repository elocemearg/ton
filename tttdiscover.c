#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <stdint.h>
#include <getopt.h>
#include <unistd.h>
#include <errno.h>
#include <error.h>
#include <time.h>
#include <assert.h>

#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>

#include "tttutils.h"
#include "tttcrypt.h"

/* Magic number of discovery datagram: "TTT1" */
#define TTT_DISCOVER_MAGIC 0x54545431UL

/* Magic number of encrypted part of discovery datagram, once decrypted:
 * "ttt1" */
#define TTT_DISCOVER_MAGIC2 0x74747431UL

/* Arbitrary multicast address which the announcer multicasts to and the
 * listener subscribes to. */
#define TTT_MULTICAST_ADDR "239.14.42.200"

#define TTT_ENC_PLAIN 0 /* not permitted by default */
#define TTT_ENC_AES_256_CBC 1

#define DISCOVER_TIMESTAMP_TOLERANCE_SEC 300

typedef uint16_t PORT;

struct ttt_payload_raw {
    uint32_t magic;
    uint16_t encryption; /* 0 = no encryption, 1 = ... */
    uint16_t payload_length;
    char payload[256];
};

#define DISCOVER_RD_OFFSET_MAGIC 0
#define DISCOVER_RD_OFFSET_ENC 4
#define DISCOVER_RD_OFFSET_PLEN 7
#define DISCOVER_RD_OFFSET_PAYLOAD 8
/* Raw datagram data is as follows. All integers are in network byte order.
 * A valid TTT datagram is no more than 263 bytes.
 *
 * Position  Type      Description
 * 0-3       uint32    Magic number 0x54545431
 * 4-5       uint16    Encryption type.
 *                       0 = no encryption.
 *                       1 = AES-256-CBC.
 * 6         uint8     Reserved. Announcers must set this to 0.
 * 7         uint8     Payload length in bytes. Maximum length 255.
 * 8+        byte[payload_length]
 *                     Encrypted payload.
 */

#define DISCOVER_P_OFFSET_MAGIC 0
#define DISCOVER_P_OFFSET_CRC 4
#define DISCOVER_P_OFFSET_CRC_DATA_START 8
#define DISCOVER_P_OFFSET_RANDOM 8
#define DISCOVER_P_OFFSET_TIMESTAMP 24
#define DISCOVER_P_OFFSET_INV_PORT 28
#define DISCOVER_P_LENGTH 30
/* Unencrypted payload is as follows. All integers are in network byte
 * order.
 *
 * Position  Type      Description
 * 0-3       uint32    Magic number 0x54545432
 * 4-7       uint32    CRC32 of payload bytes 8 to (plaintext payload length-1) inclusive.
 * 8-23      byte[16]  16 random bytes generated by sender.
 * 24-27     uint32    Lower 32 bits of Unix timestamp, to protect against
 *                       replay attacks.
 * 28-29     uint16    Invitation port number.
 * 30+                 Reserved for future expansion
 *
 * The encrypted payload may be up to 255 bytes long. If there are any bytes
 * after byte position 29 they should be ignored. This area may be used in
 * later versions.
 */

struct ttt_discover_result {
    uint32_t magic;
    PORT invitation_port;
};

/* Don't need to define this on Windows */
int closesocket(int fd) {
    return close(fd);
}

static uint32_t
uint32_ntoh(const char *buf, int offset) {
    return ntohl(*(const uint32_t *)(buf + offset));
}

static uint16_t
uint16_ntoh(const char *buf, int offset) {
    return ntohs(*(const uint16_t *)(buf + offset));
}

static void
uint32_hton(char *buf, int offset, uint32_t value) {
    value = htonl(value);
    memcpy(buf + offset, &value, sizeof(value));
}

static void
uint16_hton(char *buf, int offset, uint16_t value) {
    value = htons(value);
    memcpy(buf + offset, &value, sizeof(value));
}

static uint32_t
crc32(const char *data, size_t length) {
    static uint32_t crc32_table[256] = {0};
    static int crc32_table_generated = 0;
    uint32_t checksum = 0xFFFFFFFFU;

    if (!crc32_table_generated) {
        for (uint32_t i = 0; i < 256; i++) {
            uint32_t ch = i;
            uint32_t crc = 0;
            for (int j = 0; j < 8; j++) {
                uint32_t b = (ch ^ crc) & 1;
                crc >>= 1;
                if (b)
                    crc ^= 0xEDB88320;
                ch >>= 1;
            }
            crc32_table[i] = crc;
        }
        crc32_table_generated = 1;
    }

    for (size_t i = 0; i < length; i++) {
        const uint32_t b = (checksum ^ data[i]) & 0xff;
        checksum = (checksum >> 8) ^ crc32_table[b];
    }
    return checksum ^ 0xFFFFFFFFU;
}

static int
validate_datagram(void *datagram, int datagram_length, const char *secret,
        size_t secret_length, int allow_unencrypted, int verbose,
        struct ttt_discover_result *result) {
    unsigned long magic;
    unsigned long crc32_exp, crc32_obs;
    unsigned short enc;
    unsigned short enc_payload_length;
    unsigned short inv_port;
    unsigned long datagram_timestamp, ts_diff;
    int payload_length;
    time_t now;
    char *enc_payload_start;
    char payload[256];

    if (datagram_length < 8 || datagram_length > 263) {
        if (verbose)
            error(0, 0, "validate_datagram: invalid length %d", datagram_length);
        return -1;
    }

    magic = uint32_ntoh(datagram, DISCOVER_RD_OFFSET_MAGIC);
    enc = uint16_ntoh(datagram, DISCOVER_RD_OFFSET_ENC);
    enc_payload_length = uint16_ntoh(datagram, DISCOVER_RD_OFFSET_PLEN - 1) & 0xff;
    enc_payload_start = ((char *) datagram) + DISCOVER_RD_OFFSET_PAYLOAD;

    if (magic != TTT_DISCOVER_MAGIC) {
        if (verbose)
            error(0, 0, "validate_datagram: first magic number incorrect (expected 0x%08lx, observed 0x%08lx)", TTT_DISCOVER_MAGIC, magic);
        return -1;
    }

    if (enc != 0 && enc != 1) {
        if (verbose)
            error(0, 0, "validate_datagram: invalid encryption type %hu", enc);
        return -1;
    }

    if (enc == 0) {
        if (!allow_unencrypted) {
            if (verbose)
                error(0, 0, "validate_datagram: datagram is not encrypted, rejecting it.");
            return -1;
        }
        memcpy(payload, enc_payload_start, enc_payload_length);
        payload_length = enc_payload_length;
    }
    else {
        payload_length = ttt_aes_256_cbc_decrypt(enc_payload_start, enc_payload_length, payload, sizeof(payload), secret, secret_length);
        if (payload_length < 0) {
            error(0, 0, "validate_datagram: ttt_aes_256_cbc_decrypt() failed");
            return -1;
        }
    }

    if (verbose) {
        ttt_dump_hex(payload, payload_length, "decrypted payload");
    }

    magic = uint32_ntoh(payload, DISCOVER_P_OFFSET_MAGIC);
    crc32_exp = uint32_ntoh(payload, DISCOVER_P_OFFSET_CRC);

    if (magic != TTT_DISCOVER_MAGIC2) {
        if (verbose)
            error(0, 0, "validate_datagram: second magic number incorrect (expected 0x%08lx, observed 0x%08lx)", TTT_DISCOVER_MAGIC2, magic);
        return -1;
    }

    crc32_obs = crc32(payload + DISCOVER_P_OFFSET_CRC_DATA_START, payload_length - DISCOVER_P_OFFSET_CRC_DATA_START);
    if (crc32_obs != crc32_exp) {
        if (verbose)
            error(0, 0, "validate_datagram: CRC32 incorrect (expected 0x%08lx, calculated 0x%08lx)", crc32_exp, crc32_obs);
        return -1;
    }

    datagram_timestamp = uint32_ntoh(payload, DISCOVER_P_OFFSET_TIMESTAMP);
    now = time(NULL);
    ts_diff = (unsigned long) (now & 0xFFFFFFFF) - datagram_timestamp;
    if (abs((int32_t)ts_diff) > DISCOVER_TIMESTAMP_TOLERANCE_SEC) {
        if (verbose)
            error(0, 0, "validate_datagram: timestamp out of date, difference %d seconds", abs((int32_t) ts_diff));
        return -1;
    }

    inv_port = uint16_ntoh(payload, DISCOVER_P_OFFSET_INV_PORT);

    result->magic = magic;
    result->invitation_port = inv_port;

    return 0;
}

static int
make_announce_datagram(char *dest, int dest_max, const char *secret,
        size_t secret_length, int enc_type, PORT invitation_port) {
    char plain[256];
    int plain_payload_length;
    int encrypted_payload_length;

    uint32_hton(dest, DISCOVER_RD_OFFSET_MAGIC, TTT_DISCOVER_MAGIC);
    uint16_hton(dest, DISCOVER_RD_OFFSET_ENC, enc_type);

    memset(plain, 0, sizeof(plain));
    uint32_hton(plain, DISCOVER_P_OFFSET_MAGIC, TTT_DISCOVER_MAGIC2);
    ttt_set_random_bytes(plain + DISCOVER_P_OFFSET_RANDOM, 16);
    uint32_hton(plain, DISCOVER_P_OFFSET_TIMESTAMP, (uint32_t) (time(NULL) & 0xFFFFFFFF));
    uint16_hton(plain, DISCOVER_P_OFFSET_INV_PORT, invitation_port);

    plain_payload_length = DISCOVER_P_LENGTH;

    uint32_hton(plain, DISCOVER_P_OFFSET_CRC, crc32(plain + DISCOVER_P_OFFSET_CRC_DATA_START, plain_payload_length - DISCOVER_P_OFFSET_CRC_DATA_START));

    if (enc_type == TTT_ENC_PLAIN) {
        if (dest_max < DISCOVER_RD_OFFSET_PAYLOAD + plain_payload_length) {
            error(0, 0, "make_announce_datagram: dest_max is too small (%d < %d)", dest_max, DISCOVER_RD_OFFSET_PAYLOAD + plain_payload_length);
            return -1;
        }
        memcpy(dest + DISCOVER_RD_OFFSET_PAYLOAD, plain, plain_payload_length);
        encrypted_payload_length = plain_payload_length;
    }
    else if (enc_type == TTT_ENC_AES_256_CBC) {
        encrypted_payload_length = ttt_aes_256_cbc_encrypt(plain,
                plain_payload_length, dest + DISCOVER_RD_OFFSET_PAYLOAD,
                dest_max - DISCOVER_RD_OFFSET_PAYLOAD, secret, secret_length);
        if (encrypted_payload_length < 0) {
            error(0, 0, "make_announce_datagram: ttt_aes_256_cbc_encrypt() failed");
            return -1;
        }
    }
    else {
        error(0, 0, "make_announce_datagram: unrecognised enc_type %d", enc_type);
        return -1;
    }

    uint16_hton(dest, 6, encrypted_payload_length);
    return 8 + encrypted_payload_length;
}

int
discover_listen(const char *listen_addr, PORT listen_port,
        const char *multicast_rendezvous_addr, const char *secret,
        size_t secret_length, int allow_unencrypted,
        struct sockaddr_storage *peer_addr_r,
        int *peer_addr_length, PORT *peer_port_r) {
    int rc;
    struct addrinfo hints;
    struct addrinfo *addrinfo = NULL;
    char port_str[20];
    int listener = -1;
    const int one = 1;
    int discovered = 0;
    int attempts_made = 0;
    int attempts_allowed = 10;
    struct sockaddr **multicast_if_addrs = NULL;
    int num_multicast_if_addrs = 0;

    memset(&hints, 0, sizeof(hints));
    hints.ai_family = AF_UNSPEC;
    hints.ai_socktype = SOCK_DGRAM;
    hints.ai_flags = AI_PASSIVE;

    snprintf(port_str, sizeof(port_str), "%hu", listen_port);

    rc = getaddrinfo(listen_addr, port_str, &hints, &addrinfo);
    if (rc != 0) {
        error(0, errno, "discover_listen: getaddrinfo");
        goto fail;
    }

    listener = socket(addrinfo->ai_family, addrinfo->ai_socktype, addrinfo->ai_protocol);
    if (listener < 0) {
        error(0, errno, "discover_listen: socket");
        goto fail;
    }

    if (setsockopt(listener, SOL_SOCKET, SO_REUSEADDR, &one, sizeof(one)) != 0) {
        error(0, errno, "discover_listen: setsockopt");
        goto fail;
    }

    rc = bind(listener, addrinfo->ai_addr, addrinfo->ai_addrlen);
    if (rc != 0) {
        error(0, errno, "discover_listen: bind");
        goto fail;
    }

    multicast_if_addrs = ttt_get_multicast_if_addrs(&num_multicast_if_addrs);
    for (int i = 0; i < num_multicast_if_addrs; i++) {
        /* Your ideas are intriguing to me
         * and I wish to subscribe to your newsletter. */
        struct sockaddr *sa = multicast_if_addrs[i];
        if (sa->sa_family == AF_INET) {
            struct ip_mreq group;
            group.imr_multiaddr.s_addr = inet_addr(multicast_rendezvous_addr);
            group.imr_interface.s_addr = ((struct sockaddr_in *) sa)->sin_addr.s_addr;
            if (setsockopt(listener, IPPROTO_IP, IP_ADD_MEMBERSHIP, (char *) &group, sizeof(group)) != 0) {
                error(0, errno, "discover_listen: setsockopt IP_ADD_MEMBERSHIP");
                goto fail;
            }
        }
    }

    do {
        char datagram[512];
        struct sockaddr_storage peer_addr;
        socklen_t addr_len = sizeof(peer_addr);
        rc = recvfrom(listener, datagram, sizeof(datagram), 0, (struct sockaddr *) &peer_addr, &addr_len);
        if (rc < 0) {
            error(0, errno, "discover_listen: recvfrom");
        }
        else {
            struct ttt_discover_result result;
            ttt_dump_hex(datagram, rc, "received datagram");
            if (validate_datagram(datagram, rc, secret, secret_length,
                        allow_unencrypted, 1, &result) == 0) {
                *peer_port_r = result.invitation_port;
                memcpy(peer_addr_r, &peer_addr, addr_len);
                *peer_addr_length = addr_len;
                discovered = 1;
            }
        }
        attempts_made++;
    } while (!discovered && attempts_made < attempts_allowed);

    if (discovered)
        rc = 0;
    else
        rc = -1;
end:
    if (addrinfo)
        freeaddrinfo(addrinfo);
    if (listener >= 0)
        closesocket(listener);
    ttt_free_addrs(multicast_if_addrs, num_multicast_if_addrs);
    return rc;

fail:
    rc = -1;
    goto end;
}

int
discover_announce(PORT discover_port, const char *multicast_rendezvous_addr,
        const char *secret, size_t secret_length, int unencrypted,
        PORT invitation_port, int num_announcements, int announcement_gap_ms,
        int multicast_ttl) {
    int rc;
    struct addrinfo hints;
    char port_str[20];
    const int one = 1;
    char datagram[262];
    int datagram_length;
    struct sockaddr **broadcast_if_addrs = NULL;
    int num_broadcast_if_addrs = 0;
    struct sockaddr **multicast_if_addrs = NULL;
    int num_multicast_if_addrs = 0;
    struct addrinfo *multicast_dest_addrinfo = NULL;
    int *sockets = NULL;
    int num_sockets = 0;

    /* To maximise the chance of our announcement reaching our peer, we want
     * to try a broadcast packet on every interface on which we can broadcast,
     * and a multicast packet on every interface that supports multicast and
     * has a non-public IP address. */
    broadcast_if_addrs = ttt_get_broadcast_if_addrs(&num_broadcast_if_addrs);
    multicast_if_addrs = ttt_get_multicast_if_addrs(&num_multicast_if_addrs);
    if (num_broadcast_if_addrs <= 0 && num_multicast_if_addrs <= 0) {
        error(0, 0, "discover_announce: no suitable network interfaces!");
        return -1;
    }

    if (num_broadcast_if_addrs < 0)
        num_broadcast_if_addrs = 0;
    if (num_multicast_if_addrs < 0)
        num_multicast_if_addrs = 0;

    num_sockets = num_broadcast_if_addrs + num_multicast_if_addrs;
    sockets = malloc(sizeof(int) * num_sockets);
    if (sockets == NULL) {
        error(0, errno, "malloc");
        goto fail;
    }
    for (int i = 0; i < num_sockets; i++) {
        sockets[i] = -1;
    }

    for (int i = 0; i < num_sockets; i++) {
        struct sockaddr *sa = (i < num_broadcast_if_addrs) ? broadcast_if_addrs[i] : multicast_if_addrs[i - num_broadcast_if_addrs];
        sockets[i] = socket(sa->sa_family, SOCK_DGRAM, 0);
        if (sockets[i] < 0) {
            error(0, errno, "socket");
            goto fail;
        }
        if (i < num_broadcast_if_addrs) {
            rc = setsockopt(sockets[i], SOL_SOCKET, SO_BROADCAST, &one, sizeof(one));
            if (rc < 0) {
                error(0, errno, "discover_announce: setsockopt SO_BROADCAST");
                goto fail;
            }

            if (sa->sa_family == AF_INET) {
                ((struct sockaddr_in *) sa)->sin_port = htons(discover_port);
            }
            else if (sa->sa_family == AF_INET6) {
                ((struct sockaddr_in6 *) sa)->sin6_port = htons(discover_port);
            }
        }
        else {
            /* setsockopt takes only IPv4 in_addr structs, so
             * ttt_get_multicast_if_addrs() only returns IPv4 interfaces */
            struct sockaddr_in *sin;
            assert(sa->sa_family == AF_INET);
            sin = (struct sockaddr_in *) sa;
            rc = setsockopt(sockets[i], IPPROTO_IP, IP_MULTICAST_IF, &sin->sin_addr, sizeof(sin->sin_addr));
            if (rc != 0) {
                error(0, errno, "discover_announce: setsockopt IP_MULTICAST_IF");
                goto fail;
            }

            rc = setsockopt(sockets[i], IPPROTO_IP, IP_MULTICAST_TTL, &multicast_ttl, sizeof(multicast_ttl));
            if (rc != 0) {
                error(0, errno, "discover_announce: setsockopt IP_MULTICAST_TTL");
                goto fail;
            }
        }
    }

    /* Get an addrinfo for our multicast rendezvous address, which we will be
     * announcing to as well as to any broadcast addresses we find. */
    memset(&hints, 0, sizeof(hints));
    hints.ai_family = AF_UNSPEC;
    hints.ai_socktype = SOCK_DGRAM;
    hints.ai_flags = AI_PASSIVE;
    snprintf(port_str, sizeof(port_str), "%hu", discover_port);
    rc = getaddrinfo(multicast_rendezvous_addr, port_str, &hints, &multicast_dest_addrinfo);
    if (rc != 0) {
        error(0, errno, "discover_announce: getaddrinfo multicast");
        goto fail;
    }

    for (int announcement = 0; announcement < num_announcements; announcement++) {
        ssize_t bytes_sent;

        /* Build a new datagram for every attempt, so the timestamp doesn't
         * get stale. */
        datagram_length = make_announce_datagram(datagram, sizeof(datagram),
                secret, secret_length, unencrypted ? TTT_ENC_PLAIN : TTT_ENC_AES_256_CBC, invitation_port);
        if (datagram_length < 0) {
            error(0, errno, "discover_announce: failed to build datagram");
            goto fail;
        }

        if (announcement > 0) {
            usleep(((useconds_t) announcement_gap_ms) * 1000);
        }

        for (int si = 0; si < num_sockets; si++) {
            struct sockaddr *sa;
            int sa_len;
            if (si < num_broadcast_if_addrs) {
                sa = broadcast_if_addrs[si];
                if (sa->sa_family == AF_INET)
                    sa_len = sizeof(struct sockaddr_in);
                else if (sa->sa_family == AF_INET6)
                    sa_len = sizeof(struct sockaddr_in6);
                else
                    continue;
            }
            else {
                sa = multicast_dest_addrinfo->ai_addr;
                sa_len = multicast_dest_addrinfo->ai_addrlen;
            }

            bytes_sent = sendto(sockets[si], datagram, datagram_length, 0, sa, sa_len);
            if (bytes_sent < 0) {
                error(0, errno, "discover_announce: sendto");
            }
            else if (bytes_sent < datagram_length) {
                error(0, 0, "discover_announce: expected to send %d bytes but only sent %d", datagram_length, (int) bytes_sent);
            }
        }
    }

    rc = 0;
end:
    for (int i = 0; i < num_sockets; i++) {
        if (sockets[i] >= 0)
            closesocket(sockets[i]);
    }
    free(sockets);
    if (multicast_dest_addrinfo != NULL) {
        freeaddrinfo(multicast_dest_addrinfo);
    }
    ttt_free_addrs(broadcast_if_addrs, num_broadcast_if_addrs);
    ttt_free_addrs(multicast_if_addrs, num_multicast_if_addrs);
    return rc;

fail:
    rc = -1;
    goto end;
}

int main(int argc, char **argv) {
    int c;
    int listen_mode = 0;
    char *secret = "";
    int discover_port = 28441;
    PORT invitation_port = 12345;
    int rc;
    int exit_status = 0;
    int multicast_ttl = 1;
    int allow_unencrypted = 0;

    while ((c = getopt(argc, argv, "ls:p:i:t:n")) != -1) {
        switch (c) {
            case 'l':
                listen_mode = 1;
                break;

            case 's':
                secret = optarg;
                break;

            case 'p':
                discover_port = atoi(optarg);
                break;

            case 'i':
                invitation_port = atoi(optarg);
                break;

            case 'n':
                allow_unencrypted = 1;
                break;

            case 't':
                multicast_ttl = atoi(optarg);
                if (multicast_ttl < 1 || multicast_ttl > 10) {
                    error(1, 0, "multicast TTL must be between 1 and 10");
                }
                break;

            default:
                exit(1);
        }
    }

    if (listen_mode) {
        struct sockaddr_storage peer_addr;
        int peer_addr_len;
        PORT peer_invitation_port;

        rc = discover_listen(NULL, (PORT) discover_port, TTT_MULTICAST_ADDR,
                secret, strlen(secret), allow_unencrypted, &peer_addr,
                &peer_addr_len, &peer_invitation_port);
        if (rc != 0) {
            error(0, 0, "discover_listen failed.");
            exit_status = 1;
        }
        else {
            char peer_addr_str[100];
            char peer_port_str[30];
            rc = getnameinfo((struct sockaddr *) &peer_addr, sizeof(peer_addr),
                    peer_addr_str, sizeof(peer_addr_str),
                    peer_port_str, sizeof(peer_port_str),
                    NI_NUMERICHOST | NI_NUMERICSERV);
            if (rc != 0) {
                error(0, 0, "getnameinfo: %s", gai_strerror(rc));
                exit_status = 1;
            }
            else {
                printf("Discovered: %s port %s, invitation port %hu\n", peer_addr_str, peer_port_str, peer_invitation_port);
            }
        }
    }
    else {
        rc = discover_announce((PORT) discover_port, TTT_MULTICAST_ADDR,
                secret, strlen(secret), allow_unencrypted, invitation_port,
                10, 1000, multicast_ttl);
        if (rc != 0) {
            error(0, 0, "discover_announce failed.");
            exit_status = 1;
        }
    }

    return exit_status;
}
